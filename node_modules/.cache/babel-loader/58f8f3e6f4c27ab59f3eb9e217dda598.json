{"ast":null,"code":"import _toConsumableArray from\"C:/Users/HP/Desktop/Main-WFM/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";// array in local storage for registered users\nvar users=JSON.parse(localStorage.getItem('users'))||[];export function configureFakeBackend(){var realFetch=window.fetch;window.fetch=function(url,opts){return new Promise(function(resolve,reject){// wrap in timeout to simulate server api call\nsetTimeout(function(){// authenticate\nif(url.endsWith('/users/authenticate')&&opts.method==='POST'){// get parameters from post request\nvar params=JSON.parse(opts.body);// find if any user matches login credentials\nvar filteredUsers=users.filter(function(user){return user.username===params.username&&user.password===params.password;});if(filteredUsers.length){// if login details are valid return user details and fake jwt token\nvar user=filteredUsers[0];var responseJson={id:user.id,username:user.username,firstName:user.firstName,lastName:user.lastName,token:'fake-jwt-token'};resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(responseJson));}});}else{// else return error\nreject('Username or password is incorrect');}return;}// get users\nif(url.endsWith('/users')&&opts.method==='GET'){// check for fake auth token in header and return users if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(users));}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// get user by id\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='GET'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar urlParts=url.split('/');var id=parseInt(urlParts[urlParts.length-1]);var matchedUsers=users.filter(function(user){return user.id===id;});var _user=matchedUsers.length?matchedUsers[0]:null;// respond 200 OK with user\nresolve({ok:true,text:function text(){return JSON.stringify(_user);}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// register user\nif(url.endsWith('/users/register')&&opts.method==='POST'){// get new user object from post body\nvar newUser=JSON.parse(opts.body);// validation\nvar duplicateUser=users.filter(function(user){return user.username===newUser.username;}).length;if(duplicateUser){reject('Username \"'+newUser.username+'\" is already taken');return;}// save new user\nnewUser.id=users.length?Math.max.apply(Math,_toConsumableArray(users.map(function(user){return user.id;})))+1:1;users.push(newUser);localStorage.setItem('users',JSON.stringify(users));// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});return;}// delete user\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='DELETE'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar _urlParts=url.split('/');var _id=parseInt(_urlParts[_urlParts.length-1]);for(var i=0;i<users.length;i++){var _user2=users[i];if(_user2.id===_id){// delete user\nusers.splice(i,1);localStorage.setItem('users',JSON.stringify(users));break;}}// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// pass through any requests not handled above\nrealFetch(url,opts).then(function(response){return resolve(response);});},500);});};}","map":{"version":3,"sources":["C:/Users/HP/Desktop/Main-WFM/frontend/src/helpers/fake-backend.js"],"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"mappings":"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","sourcesContent":["// array in local storage for registered users\r\nlet users = JSON.parse(localStorage.getItem('users')) || [];\r\n    \r\nexport function configureFakeBackend() {\r\n    let realFetch = window.fetch;\r\n    window.fetch = function (url, opts) {\r\n        return new Promise((resolve, reject) => {\r\n            // wrap in timeout to simulate server api call\r\n            setTimeout(() => {\r\n\r\n                // authenticate\r\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\r\n                    // get parameters from post request\r\n                    let params = JSON.parse(opts.body);\r\n\r\n                    // find if any user matches login credentials\r\n                    let filteredUsers = users.filter(user => {\r\n                        return user.username === params.username && user.password === params.password;\r\n                    });\r\n\r\n                    if (filteredUsers.length) {\r\n                        // if login details are valid return user details and fake jwt token\r\n                        let user = filteredUsers[0];\r\n                        let responseJson = {\r\n                            id: user.id,\r\n                            username: user.username,\r\n                            firstName: user.firstName,\r\n                            lastName: user.lastName,\r\n                            token: 'fake-jwt-token'\r\n                        };\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\r\n                    } else {\r\n                        // else return error\r\n                        reject('Username or password is incorrect');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get users\r\n                if (url.endsWith('/users') && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get user by id\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        let matchedUsers = users.filter(user => { return user.id === id; });\r\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\r\n\r\n                        // respond 200 OK with user\r\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // register user\r\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\r\n                    // get new user object from post body\r\n                    let newUser = JSON.parse(opts.body);\r\n\r\n                    // validation\r\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\r\n                    if (duplicateUser) {\r\n                        reject('Username \"' + newUser.username + '\" is already taken');\r\n                        return;\r\n                    }\r\n\r\n                    // save new user\r\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\r\n                    users.push(newUser);\r\n                    localStorage.setItem('users', JSON.stringify(users));\r\n\r\n                    // respond 200 OK\r\n                    resolve({ ok: true, text: () => Promise.resolve() });\r\n\r\n                    return;\r\n                }\r\n\r\n                // delete user\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        for (let i = 0; i < users.length; i++) {\r\n                            let user = users[i];\r\n                            if (user.id === id) {\r\n                                // delete user\r\n                                users.splice(i, 1);\r\n                                localStorage.setItem('users', JSON.stringify(users));\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // respond 200 OK\r\n                        resolve({ ok: true, text: () => Promise.resolve() });\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // pass through any requests not handled above\r\n                realFetch(url, opts).then(response => resolve(response));\r\n\r\n            }, 500);\r\n        });\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}